<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的学习记录，部分资料来自网络"><title>Java 8 并发 Threads 和 Executors | tt_study</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 8 并发 Threads 和 Executors</h1><a id="logo" href="/.">tt_study</a><p class="description">我的学习记录，部分资料来自网络</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 8 并发 Threads 和 Executors</h1><div class="post-meta">Feb 5, 2018<span> | </span><span class="category"><a href="/categories/Java基础/">Java基础</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Threads-和-Runnables"><span class="toc-text">Threads 和 Runnables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executors"><span class="toc-text">Executors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callables-和-Futures"><span class="toc-text">Callables 和 Futures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timeouts"><span class="toc-text">Timeouts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InvokeAll"><span class="toc-text">InvokeAll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InvokeAny"><span class="toc-text">InvokeAny</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduled-Executors"><span class="toc-text">Scheduled Executors</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p>原文地址： <a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/" target="_blank" rel="noopener">Java 8 Concurrency Tutorial: Threads and Executors</a></p>
</blockquote>
<p><code>Java 5</code> 初次引入了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html" target="_blank" rel="noopener">Concurrency API</a>，并在随后的发布版本中不断优化和改进。这篇文章的大部分概念也适用于老的版本。我的代码示例主要聚焦在<code>Java 8</code>上，并大量适用 <code>lambda</code> 表达式和一些新特性。如果你还不熟悉 <code>lambda</code> 表达式，建议先阅读 <a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="noopener">Java 8 Tutorial</a>。</p>
<h3 id="Threads-和-Runnables"><a href="#Threads-和-Runnables" class="headerlink" title="Threads 和 Runnables"></a><code>Threads</code> 和 <code>Runnables</code></h3><p>所有现代操作系统都是通过<code>进程</code>和<code>线程</code>来支持并发的。<code>进程</code>通常是相互独立运行的程序实例。例如，你启动一个 <code>Java</code> 程序，操作系统会产生一个新的<code>进程</code>和其他程序并行运行。在这些<code>进程</code>中可以利用<code>线程</code>同时执行代码。这样我们就可以充分利用 <code>CPU</code>。</p>
<p><code>Java</code> 从 <code>JDK 1.0</code> 开始就支持<code>线程</code>。在开始一个新<code>线程</code>之前，必须先指定运行的代码，通常称为 <code>Task</code>。下面是通过实现 <code>Runnable</code> 接口来启动一个新线程的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; &#123;</span><br><span class="line">    String threadName = Thread.currentThread().getName();</span><br><span class="line">    System.out.println(&quot;Hello &quot; + threadName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">task.run();</span><br><span class="line"></span><br><span class="line">Thread thread = new Thread(task);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Done!&quot;);</span><br></pre></td></tr></table></figure>
<p>由于 <code>Runnable</code> 是一个<code>函数式</code>接口，我们可以使用 <code>lambda</code> 表达式来打印线程的名字到控制台。我们直接在主线程上执行<code>Runnable</code>，然后开始一个新线程。在控制台你将看到这样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello main</span><br><span class="line">Hello Thread-0</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello main</span><br><span class="line">Done!</span><br><span class="line">Hello Thread-0</span><br></pre></td></tr></table></figure>
<p>由于是<code>并发</code>执行，我们无法预测 <code>Runnable</code> 是在打印 <code>Done</code> 之前还是之后调用，顺序不是不确定的，因此<code>并发编程</code>成为大型应用程序开发中一项复杂的任务。</p>
<p>线程也可以休眠一段时间，例如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = () -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(&quot;Foo &quot; + name);</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;Bar &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread = new Thread(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p>执行上面的代码会在两个打印语句之间停留1秒钟。<code>TimeUnit</code> 是一个时间单位的枚举，或者可以通过调用 <code>Thread.sleep(1000)</code> 实现。</p>
<p>使用 <code>Thread</code> 类可能非常繁琐且容易出错。由于这个原因，在2004年，<code>Java 5</code>版本引入了 <code>Concurrency API</code>。<code>API</code> 位于 <code>java.util.concurrent</code> 包下，包含了许多有用的有关并发编程的类。从那时起，每个新发布的 <code>Java</code> 版本都增加了并发 <code>API</code>，<code>Java 8</code> 也提供了新的类和方法来处理并发。</p>
<p>现在我们来深入了解一下<code>Concurrency API</code>中最重要的部分 - <code>executor services</code>。</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p><code>Concurrency API</code> 引入了 <code>ExecutorService</code> 的概念，作为处理线程的高级别方式用来替代 <code>Threads</code>。 <code>Executors</code> 能够异步的执行任务，并且通常管理一个线程池。这样我们就不用手动的去创建线程了，线程池中的所有线程都将被重用。从而可以在一个<code>executor service</code> 的整个应用程序生命周期中运行尽可能多的并发任务。</p>
<p>下面是一个简单的 <code>executors</code> 例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    String threadName = Thread.currentThread().getName();</span><br><span class="line">    System.out.println(&quot;Hello &quot; + threadName);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// =&gt; Hello pool-1-thread-1</span><br></pre></td></tr></table></figure>
<p><code>Executors</code> 类提供了方便的工厂方法来创建不同类型的 <code>executor services</code> 。在这个例子中使用了只执行一个线程的 <code>executor</code>。</p>
<p>执行结果看起来和上面的示例类似，但是你会注意到一个重要区别：<code>Java</code> 进程永远不会停止，执行者必须明确的停止它，否则它会不断的接受新的任务。</p>
<p><code>ExecutorService</code> 为此提供了两种方法：<code>shutdown()</code> 等待当前任务执行完毕，而 <code>shutdownNow()</code> 则中断所有正在执行的任务，并立即关闭执行程序。在 <code>shudown</code> 之后不能再提交任务到线程池。</p>
<p>下面是我关闭程序的首选方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;attempt to shutdown executor&quot;);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    executor.awaitTermination(5, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e) &#123;</span><br><span class="line">    System.err.println(&quot;tasks interrupted&quot;);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    if (!executor.isTerminated()) &#123;</span><br><span class="line">        System.err.println(&quot;cancel non-finished tasks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdownNow();</span><br><span class="line">    System.out.println(&quot;shutdown finished&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行者调用 <code>shutdown</code> 关闭 <code>executor</code>，在等待 5 秒钟钟后，不管任务有没有执行完毕都调用 <code>shutdownNow</code> 中断正在执行的任务而关闭。</p>
<h3 id="Callables-和-Futures"><a href="#Callables-和-Futures" class="headerlink" title="Callables 和 Futures"></a><code>Callables</code> 和 <code>Futures</code></h3><p>除了 <code>Runnable</code> 以外，<code>executors</code> 还支持 <code>Callable</code> 任务，和 <code>Runnable</code> 一样是一个函数式接口，但它是有返回值的。</p>
<p>下面是一个使用 <code>lambda</code> 表达式定义的 <code>Callable</code> ，在睡眠 1 秒后返回一个整形值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;task interrupted&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和 <code>Runnable</code> 一样，<code>Callable</code> 也可以提交到 <code>executor services</code>，但是执行的结果是什么？由于 <code>submit()</code> 不等待任务执行完成，<code>executor service</code> 不能直接返回调用的结果。相对应的，它返回一个 <code>Future</code> 类型的结果，使用 <code>Future</code> 可以检索实际执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(1);</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;future done? &quot; + future.isDone());</span><br><span class="line"></span><br><span class="line">Integer result = future.get();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;future done? &quot; + future.isDone());</span><br><span class="line">System.out.print(&quot;result: &quot; + result);</span><br></pre></td></tr></table></figure>
<p>在将 <code>Callable</code> 提交给 <code>executor</code> 后，首先通过 <code>isDone()</code> 来检查 <code>future</code> 是否执行完毕。我敢肯定，情况并非如此，因为上面的调用在返回整数之前睡眠了 1 秒钟。</p>
<p>调用方法 <code>get()</code> 会阻塞当前线程，直到 <code>callable</code> 执行完成返回结果，现在 <code>future</code> 执行完成，并在控制台输出下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">future done? false</span><br><span class="line">future done? true</span><br><span class="line">result: 123</span><br></pre></td></tr></table></figure>
<p><code>Future</code> 与 <code>executor service</code> 紧密结合，如果关闭 <code>executor service</code>， 每个 <code>Future</code> 都会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executor.shutdownNow();</span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>
<p>这里创建 <code>executor</code> 的方式与前面的示例不同，这里使用 <code>newFixedThreadPool(1)</code> 来创建一个线程数量为 1 的线程池来支持 <code>executor</code>， 这相当于 <code>newSingleThreadExecutor()</code> ，稍后我们我们会通过传递一个大于 1 的值来增加线程池的大小。</p>
<h3 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h3><p>任何对 <code>future.get()</code>的调用都会阻塞并等待 <code>Callable</code> 被终止。 在最坏的情况下，一个可调用函数将永远运行，从而使应用程序无法响应。可以简单地通过超时来抵消这些情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(1);</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;task interrupted&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">future.get(1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>执行上面的代码会抛出 <code>TimeoutException</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException</span><br><span class="line">    at java.util.concurrent.FutureTask.get(FutureTask.java:205)</span><br></pre></td></tr></table></figure>
<p>指定了 1 秒钟的最长等待时间，但是在返回结果之前，可调用事实上需要 2 秒钟的时间。</p>
<h3 id="InvokeAll"><a href="#InvokeAll" class="headerlink" title="InvokeAll"></a>InvokeAll</h3><p><code>Executors</code> 支持通过 <code>invokeAll()</code> 批量提交多个 <code>Callable</code> 。这个方法接受一个 <code>Callable</code> 类型集合的参数，并返回一个 <code>Future</code> 类型的 <code>List</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList(</span><br><span class="line">        () -&gt; &quot;task1&quot;,</span><br><span class="line">        () -&gt; &quot;task2&quot;,</span><br><span class="line">        () -&gt; &quot;task3&quot;);</span><br><span class="line"></span><br><span class="line">executor.invokeAll(callables)</span><br><span class="line">    .stream()</span><br><span class="line">    .map(future -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们利用 <code>Java 8</code> 的流来处理 <code>invokeAll</code> 调用返回的所有 <code>Future</code>。 我们首先映射每个 <code>Future</code> 的返回值，然后将每个值打印到控制台。 如果还不熟悉流，请阅读<a href="https://link.juejin.im?target=http%3A%2F%2Fwinterbe.com%2Fposts%2F2014%2F07%2F31%2Fjava8-stream-tutorial-examples%2F" target="_blank" rel="noopener">Java 8 Stream Tutorial</a>。</p>
<h3 id="InvokeAny"><a href="#InvokeAny" class="headerlink" title="InvokeAny"></a>InvokeAny</h3><p>批量提交可调用的另一种方法是 <code>invokeAny()</code>，它与 <code>invokeAll()</code> 略有不同。 该方法不会返回所有的 <code>Future</code> 对象，它只返回第一个执行完毕任务的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callable(String result, long sleepSeconds) &#123;</span><br><span class="line">    return () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(sleepSeconds);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用这种方法来创建一个有三个不同睡眠时间的 <code>Callable</code>。 通过 <code>invokeAny()</code>将这些可调用对象提交给 <code>executor</code>，返回最快执行完毕结果，在这种情况下，task2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList(</span><br><span class="line">    callable(&quot;task1&quot;, 2),</span><br><span class="line">    callable(&quot;task2&quot;, 1),</span><br><span class="line">    callable(&quot;task3&quot;, 3));</span><br><span class="line"></span><br><span class="line">String result = executor.invokeAny(callables);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// =&gt; task2</span><br></pre></td></tr></table></figure>
<p>上面的例子使用通过 <code>newWorkStealingPool()</code> 创建的另一种类型的 <code>executor</code>。 这个工厂方法是 <code>Java 8</code> 的一部分，并且返回一个类型为 <code>ForkJoinPool</code>的 <code>executor</code>，它与正常的 <code>executor</code> 略有不同。 它不使用固定大小的线程池，默认情况下是主机CPU的可用内核数。</p>
<h3 id="Scheduled-Executors"><a href="#Scheduled-Executors" class="headerlink" title="Scheduled Executors"></a>Scheduled Executors</h3><p>我们已经学会了如何在 <code>Executors</code> 上提交和运行任务。 为了多次定期运行任务，我们可以使用 <code>scheduled thread pools</code>。</p>
<p><code>ScheduledExecutorService</code> 能够安排任务定期运行或在一段时间过后运行一次。</p>
<p>下面代码示例一个任务在三秒钟后运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</span><br><span class="line"></span><br><span class="line">Runnable task = () -&gt; System.out.println(&quot;Scheduling: &quot; + System.nanoTime());</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.schedule(task, 3, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(1337);</span><br><span class="line"></span><br><span class="line">long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">System.out.printf(&quot;Remaining Delay: %sms&quot;, remainingDelay);</span><br></pre></td></tr></table></figure>
<p>调度任务产生一个类型为 <code>ScheduledFuture</code>的值，除了 <code>Future</code> 之外，它还提供<code>getDelay()</code> 方法来检索任务执行的剩余时间。</p>
<p>为了定时执行的任务，<code>executor</code> 提供了两个方法 <code>scheduleAtFixedRate()</code> 和<code>scheduleWithFixedDelay()</code> 。 第一种方法能够执行具有固定时间间隔的任务，例如， 每秒一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</span><br><span class="line"></span><br><span class="line">Runnable task = () -&gt; System.out.println(&quot;Scheduling: &quot; + System.nanoTime());</span><br><span class="line"></span><br><span class="line">int initialDelay = 0;</span><br><span class="line">int period = 1;</span><br><span class="line">executor.scheduleAtFixedRate(task, initialDelay, period, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>此外，此方法还可以设置延迟时间，该延迟描述了首次执行任务之前的等待时间。</p>
<p><code>scheduleWithFixedDelay()</code> 方法与 <code>scheduleAtFixedRate()</code> 略有不同，不同之处是它们的等待时间，<code>scheduleWithFixedDelay()</code> 的等待时间是在上一个任务结束和下一个任务开始之间施加的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</span><br><span class="line"></span><br><span class="line">Runnable task = () -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(&quot;Scheduling: &quot; + System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e) &#123;</span><br><span class="line">        System.err.println(&quot;task interrupted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">executor.scheduleWithFixedDelay(task, 0, 1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>本示例在执行结束和下一次执行开始之间延迟 1 秒。 初始延迟为 0，任务持续时间为 2 秒。 所以我们得到了一个0s，3s，6s，9s等的执行间隔。</p>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a class="pre" href="/2018/03/04/其他/互联网协议入门/">互联网协议入门</a><a class="next" href="/2018/02/01/其他/SpringBoot使用IDEA远程debug/">SpringBoot使用IDEA远程debug</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'wtksana',
  repo: 'wtksana.github.io',
  oauth: {
    client_id: '3337687b3c13cd764c2a',
    client_secret: '524f7e3efacf27d6614a5f2a9f623f8753a84eb5',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="wtksana.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java相关/">Java相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Centos/" style="font-size: 15px;">Centos</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Https/" style="font-size: 15px;">Https</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/IDEA/" style="font-size: 15px;">IDEA</a> <a href="/tags/VPS/" style="font-size: 15px;">VPS</a> <a href="/tags/SS/" style="font-size: 15px;">SS</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/IP/" style="font-size: 15px;">IP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/07/其他/Jenkins安装配置+部署SpringBoot/">Jenkins安装配置+部署SpringBoot</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/07/其他/各环境变量配置/">各环境变量配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/04/其他/互联网协议入门/">互联网协议入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/05/Java基础/Java 8 并发 Threads 和 Executors/">Java 8 并发 Threads 和 Executors</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/01/其他/SpringBoot使用IDEA远程debug/">SpringBoot使用IDEA远程debug</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/01/其他/SpringBoot+Nginx+Https/">阿里云+Https+Nginx+SpringBoot</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/26/其他/VPS安装SSR和BBR/">VPS安装SSR和BBR</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/03/其他/Centos通过yum安装mysql/">Centos通过yum安装mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/27/Spring/SpringBoot 项目构建/">SpringBoot 项目构建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/Java相关/redis缓存击穿、穿透、雪崩问题/">Redis缓存击穿、穿透、雪崩问题</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">tt_study.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
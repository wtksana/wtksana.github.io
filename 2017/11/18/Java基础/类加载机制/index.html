<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的学习记录，部分资料来自网络"><title>类加载机制 | tt_study</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">类加载机制</h1><a id="logo" href="/.">tt_study</a><p class="description">我的学习记录，部分资料来自网络</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">类加载机制</h1><div class="post-meta">Nov 18, 2017<span> | </span><span class="category"><a href="/categories/Java基础/">Java基础</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载的基本机制和过程"><span class="toc-text">类加载的基本机制和过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解ClassLoader"><span class="toc-text">理解ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader-vs-Class-forName"><span class="toc-text">ClassLoader vs Class.forName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载应用-可配置的策略"><span class="toc-text">类加载应用 - 可配置的策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义ClassLoader"><span class="toc-text">自定义ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用途"><span class="toc-text">用途</span></a></li></ol></li></ol></div></div><div class="post-content"><p><a href="https://juejin.im/post/59259a978d6d810058070281" target="_blank" rel="noopener">原文链接</a></p>
<p>类加载器ClassLoader就是加载其他类的类，它负责将字节码文件加载到内存，创建Class对象。与之前介绍的反射、注解、和动态代理一样，在大部分的应用编程中，我们不太需要自己实现ClassLoader。</p>
<p>不过，理解类加载的机制和过程，有助于我们更好的理解之前介绍的内容，更好的理解Java。在反射一节，我们介绍过Class的静态方法Class.forName，理解类加载器有助于我们更好的理解该方法。</p>
<p>ClassLoader一般是系统提供的，不需要自己实现，不过，通过创建自定义的ClassLoader，可以实现一些强大灵活的功能，比如：</p>
<ul>
<li><strong>热部署</strong>，在不重启Java程序的情况下，动态替换类的实现，比如Java Web开发中的JSP技术就利用自定义的ClassLoader实现修改JSP代码即生效，OSGI (Open Service Gateway Initiative)框架使用自定义ClassLoader实现动态更新。</li>
<li><strong>应用的模块化和相互隔离</strong>，不同的ClassLoader可以加载相同的类但互相隔离、互不影响。Web应用服务器如Tomcat利用这一点在一个程序中管理多个Web应用程序，每个Web应用使用自己的ClassLoader，这些Web应用互不干扰。OSGI利用这一点实现了一个动态模块化架构，每个模块有自己的ClassLoader，不同模块可以互不干扰。</li>
<li><strong>从不同地方灵活加载</strong>，系统默认的ClassLoader一般从本地的.class文件或jar文件中加载字节码文件，通过自定义的ClassLoader，我们可以从共享的Web服务器、数据库、缓存服务器等其他地方加载字节码文件。</li>
</ul>
<p>理解自定义ClassLoader有助于我们理解这些系统程序和框架，如Tomat, JSP, OSGI，在业务需要的时候，也可以借助自定义ClassLoader实现动态灵活的功能。</p>
<h3 id="类加载的基本机制和过程"><a href="#类加载的基本机制和过程" class="headerlink" title="类加载的基本机制和过程"></a>类加载的基本机制和过程</h3><p>运行Java程序，就是执行java这个命令，指定包含main方法的完整类名，以及一个classpath，即类路径。类路径可以有多个，对于直接的class文件，路径是class文件的根目录，对于jar包，路径是jar包的完整名称（包括路径和jar包名）。</p>
<p>Java运行时，会根据类的完全限定名寻找并加载类，寻找的方式基本就是在系统类和指定的类路径中寻找，如果是class文件的根目录，则直接查看是否有对应的子目录及文件，如果是jar文件，则首先在内存中解压文件，然后再查看是否有对应的类。</p>
<p>负责加载类的类就是类加载器，它的输入是完全限定的类名，输出是Class对象。类加载器不是只有一个，一般程序运行时，都会有三个：</p>
<ul>
<li><strong>启动类加载器</strong>(Bootstrap ClassLoader)：这个加载器是Java虚拟机实现的一部分，不是Java语言实现的，一般是C++实现的，它负责加载Java的基础类，主要是/lib/rt.jar，我们日常用的Java类库比如String, ArrayList等都位于该包内。</li>
<li><strong>扩展类加载器</strong>(Extension ClassLoader)：这个加载器的实现类是sun.misc.Launcher$ExtClassLoader，它负责加载Java的一些扩展类，一般是/lib/ext目录中的jar包。</li>
<li><strong>应用程序类加载器</strong>(Application ClassLoader)：这个加载器的实现类是sun.misc.Launcher$AppClassLoader，它负责加载应用程序的类，包括自己写的和引入的第三方法类库，即所有在类路径中指定的类。</li>
</ul>
<p>这三个类加载器有一定的关系，可以认为是<strong>父子关系</strong>，Application ClassLoader的父亲是Extension ClassLoader，Extension的父亲是Bootstrap ClassLoader，注意不是父子继承关系，而是<strong>父子委派关系</strong>，子ClassLoader有一个变量parent指向父ClassLoader，在子ClassLoader加载类时，一般会首先通过父ClassLoader加载，具体来说，在加载一个类时，基本过程是：</p>
<ol>
<li>判断是否已经加载过了，加载过了，直接返回Class对象，一个类只会被一个ClassLoader加载一次。</li>
<li>如果没有被加载，先让父ClassLoader去加载，如果加载成功，返回得到的Class对象。</li>
<li>在父ClassLoader没有加载成功的前提下，自己尝试加载类。</li>
</ol>
<p>这个过程一般被称为”<strong>双亲委派</strong>“模型，即优先让父ClassLoader去加载。为什么要先让父ClassLoader去加载呢？这样，<strong>可以避免Java类库被覆盖的问题，比如用户程序也定义了一个类java.lang.String，通过双亲委派，java.lang.String只会被Bootstrap ClassLoader加载，避免自定义的String覆盖Java类库的定义</strong>。</p>
<p>需要了解的是，”双亲委派”虽然是一般模型，但也有一些例外，比如：</p>
<ul>
<li><strong>自定义的加载顺序</strong>：尽管不被建议，自定义的ClassLoader可以不遵从”双亲委派”这个约定，不过，即使不遵从，以”java”开头的类也不能被自定义类加载器加载，这是由Java的安全机制保证的，以避免混乱。</li>
<li><strong>网状加载顺序</strong>：在OSGI框架中，类加载器之间的关系是一个网，每个OSGI模块有一个类加载器，不同模块之间可能有依赖关系，在一个模块加载一个类时，可能是从自己模块加载，也可能是委派给其他模块的类加载器加载。</li>
<li><strong>父加载器委派给子加载器加载</strong>：典型的例子有JNDI服务(Java Naming and Directory Interface)，它是Java企业级应用中的一项服务，具体我们就不介绍了。</li>
</ul>
<p>一个程序运行时，会创建一个Application ClassLoader，在程序中用到ClassLoader的地方，如果没有指定，一般用的都是这个ClassLoader，所以，这个ClassLoader也被称为系统类加载器(System ClassLoader)。</p>
<h3 id="理解ClassLoader"><a href="#理解ClassLoader" class="headerlink" title="理解ClassLoader"></a>理解ClassLoader</h3><p>类ClassLoader是一个抽象类，Application ClassLoader和Extension ClassLoader的具体实现类分别是sun.misc.Launcher$AppClassLoader和sun.misc.Launcher$ExtClassLoader，Bootstrap ClassLoader不是由Java实现的，没有对应的类。</p>
<p>每个Class对象都有一个方法，可以获取实际加载它的ClassLoader，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>ClassLoader有一个方法，可以获取它的父ClassLoader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title">getParent</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果ClassLoader是Bootstrap ClassLoader，返回值为null。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = ClassLoaderDemo.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(cl.getClass().getName());</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(String.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>ClassLoader有一个静态方法，可以获取默认的系统类加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>ClassLoader中有一个主要方法，用于加载类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; cls = cl.loadClass(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line">    ClassLoader actualLoader = cls.getClassLoader();</span><br><span class="line">    System.out.println(actualLoader);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，由于委派机制，Class的getClassLoader()方法返回的不一定是调用loadClass的ClassLoader，比如，上面代码中，java.util.ArrayList实际由BootStrap ClassLoader加载，所以返回值就是null。</p>
<h3 id="ClassLoader-vs-Class-forName"><a href="#ClassLoader-vs-Class-forName" class="headerlink" title="ClassLoader vs Class.forName"></a>ClassLoader vs Class.forName</h3><p>在反射一节，我们介绍过Class的两个静态方法forName：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize, ClassLoader loader)</span><br></pre></td></tr></table></figure>
<p>第一个方法使用系统类加载器加载，第二个指定ClassLoader，参数initialize表示，加载后，是否执行类的初始化代码(如static语句块)，没有指定默认为true。</p>
<p>ClassLoader的loadClass方法与forName方法都可以加载类，它们有什么不同呢？基本是一样的，不过，有一个不同，<strong>ClassLoader的loadClass不会执行类的初始化代码</strong>，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLInitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">        String className = CLInitDemo.class.getName() + <span class="string">"$Hello"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cls = cl.loadClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ClassLoader加载静态内部类Hello，Hello有一个static语句块，输出”hello”，运行该程序，类被加载了，但没有任何输出，即static语句块没有被执行。如果将loadClass的语句换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = Class.forName(className);</span><br></pre></td></tr></table></figure>
<p>则static语句块会被执行，屏幕将输出”hello”。</p>
<h3 id="类加载应用-可配置的策略"><a href="#类加载应用-可配置的策略" class="headerlink" title="类加载应用 - 可配置的策略"></a>类加载应用 - 可配置的策略</h3><p>可以通过ClassLoader的loadClass或Class.forName自己加载类，但什么情况需要自己加载类呢？</p>
<p>很多应用使用面向接口的编程，接口具体的实现类可能有很多，适用于不同的场合，具体使用哪个实现类在配置文件中配置，通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，这是一种策略模式。</p>
<h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Java类加载机制的强大之处在于，我们可以创建自定义的ClassLoader，自定义ClassLoader是Tomcat实现应用隔离、支持JSP，OSGI实现动态模块化的基础。</p>
<p>怎么自定义呢？一般而言，继承类ClassLoader，重写findClass就可以了。怎么实现findClass呢？使用自己的逻辑寻找class文件字节码的字节形式，找到后，使用如下方法转换为Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure>
<p>name表示类名，b是存放字节码数据的字节数组，有效数据从off开始，长度为len。</p>
<p>看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_DIR = <span class="string">"data/c87/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String fileName = name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">        fileName = BASE_DIR + fileName + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = BinaryFileUtils.readFileToByteArray(fileName);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"failed to load class "</span> + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyClassLoader从BASE_DIR下的路径中加载类，它使用了我们在57节介绍的BinaryFileUtils读取文件，转换为byte数组。MyClassLoader没有指定父ClassLoader，默认是系统类加载器，即ClassLoader.getSystemClassLoader()的返回值，不过，ClassLoader有一个可重写的构造方法，可以指定父ClassLoader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>MyClassLoader有什么用呢？将BASE_DIR加到classpath中不就行了，确实可以，这里主要是演示基本用法，实际中，可以从Web服务器、数据库或缓存服务器获取bytes数组，这就不是系统类加载器能做到的了。</p>
<p>不过，不把BASE_DIR放到classpath中，而是使用MyClassLoader加载，确实有一个很大的好处，可以创建多个MyClassLoader，对同一个类，每个MyClassLoader都可以加载一次，得到同一个类的不同Class对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader cl1 = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">String className = <span class="string">"shuo.laoma.dynamic.c87.HelloService"</span>;</span><br><span class="line">Class&lt;?&gt; class1 = cl1.loadClass(className);</span><br><span class="line"></span><br><span class="line">MyClassLoader cl2 = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class&lt;?&gt; class2 = cl2.loadClass(className);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (class1 != class2) &#123;</span><br><span class="line">    System.out.println(<span class="string">"different classes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cl1和cl2是两个不同的ClassLoader，class1和class2对应的类名一样，但它们是不同的对象。</p>
<p>这到底有什么用呢？</p>
<ul>
<li><strong>可以实现隔离</strong>，一个复杂的程序，内部可能按模块组织，不同模块可能使用同一个类，但使用的是不同版本，如果使用同一个类加载器，它们是无法共存的，不同模块使用不同的类加载器就可以实现隔离，Tomcat使用它隔离不同的Web应用，OSGI使用它隔离不同模块。</li>
<li><strong>可以实现热部署</strong>，使用同一个ClassLoader，类只会被加载一次，加载后，即使class文件已经变了，再次加载，得到的也还是原来的Class对象，而使用MyClassLoader，则可以先创建一个新的ClassLoader，再用它加载Class，得到的Class对象就是新的，从而实现动态更新。</li>
</ul>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a class="pre" href="/2017/11/18/Java基础/抽象类/">抽象类</a><a class="next" href="/2017/11/18/Java基础/红黑树/">红黑树</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'wtksana',
  repo: 'wtksana.github.io',
  oauth: {
    client_id: '3337687b3c13cd764c2a',
    client_secret: '524f7e3efacf27d6614a5f2a9f623f8753a84eb5',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="wtksana.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java相关/">Java相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/ZooKeeper/" style="font-size: 15px;">ZooKeeper</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/RabbitMQ/" style="font-size: 15px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Centos/" style="font-size: 15px;">Centos</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Https/" style="font-size: 15px;">Https</a> <a href="/tags/IDEA/" style="font-size: 15px;">IDEA</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/IP/" style="font-size: 15px;">IP</a> <a href="/tags/VPS/" style="font-size: 15px;">VPS</a> <a href="/tags/SS/" style="font-size: 15px;">SS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/16/Spring/SpringBoot 10.整合zk+dubbo/">SpringBoot 10.整合zk+dubbo</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/Spring/SpringBoot 9.异步调用/">SpringBoot 9.异步调用@Async</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/09/Spring/SpringBoot 8.定时任务/">SpringBoot 8.定时任务@Scheduled</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/29/Spring/SpringBoot 7.1.RabbitMQ进阶使用/">SpringBoot 7.1.RabbitMQ进阶使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/22/Spring/SpringBoot 7.整合RabbitMQ/">SpringBoot 7.整合RabbitMQ</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/20/Spring/SpringBoot 6.整合Redis和session/">SpringBoot 6.整合Redis Cache和session</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/19/Spring/SpringBoot 5.模块拆分/">SpringBoot 5.模块拆分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/16/Spring/SpringBoot 4.过滤器、监听器、拦截器/">SpringBoot 4.过滤器、监听器、拦截器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/Spring/SpringBoot 3.整合Mybatis/">SpringBoot 3.整合Mybatis</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/Spring/SpringBoot 2.继续完善/">SpringBoot 2.完善一下</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">tt_study.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>